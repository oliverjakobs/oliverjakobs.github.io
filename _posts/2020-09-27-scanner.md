---
layout: post
author: oliver
lang: C
---
Introduction and Scanner...

>Disclaimer: This is not the only or best way to do this. This is how I've done it. Maybe it helps with your project or maybe you get inspired to do something better.

For my ecs system in my game I needed an easy way to add new components and systems, so I decided to write a small code generation tool to do that for me.
Here is what I have done.

First I needed to decide on a syntax for script file which decides what code to generate. After some changes I managed to plan out some syntax that fits my needs.

{% highlight c linenos %}
define ECS_LOADER_H

include
{
    "Ecs/Ecs.h",
    "Components/Animator.h",
    "Components/Transform.h",
    "Components/RigidBody.h",
    "Components/Sprite.h",
    "Components/Movement.h",
    "Components/CameraController.h",
    "Components/Inventory.h",
    "Components/Interaction.h"
}

enum ComponentType
{
    [ COMPONENT_TRANSFORM,      sizeof(Transform),          NULL ],
    [ COMPONENT_RIGID_BODY,     sizeof(RigidBody),          NULL ],
    [ COMPONENT_MOVEMENT,       sizeof(Movement),           NULL ],
    [ COMPONENT_SPRITE,         sizeof(Sprite),             NULL ],
    [ COMPONENT_ANIMATOR,       sizeof(Animator),           AnimatorFree ],
    [ COMPONENT_CAMERA,         sizeof(CameraController),   NULL ],
    [ COMPONENT_INVENTORY,      sizeof(Inventory),          InventoryFree ],
    [ COMPONENT_INTERACTION,    sizeof(Interaction),        NULL ],
    [ COMPONENT_INTERACTOR,     sizeof(Interactor),         NULL ]
}

generate RegisterComponents(Ecs* ecs): ComponentType -> EcsRegisterComponent(ecs)
{% endhighlight %}

The first line specifies the include guard for the generated c-file and is mandatory. After that comes the inluce block, that indicates what files does the generated file needs.
...


## The Scanner

The following code was taken from Bob Nystrom's book [Crafting Interpreters](https://www.craftinginterpreters.com/)
The scanner takes in the script file and splits it into tokens. For my needs I needed these token types:

{% highlight c linenos %}
typedef struct
{
    TokenType type;

    const char* start;
    size_t len;

    int line;
} Token;
{% endhighlight %}

{% highlight c linenos %}
typedef struct
{
    const char* start;
    const char* current;
    int line;
} Scanner;
{% endhighlight %}

{% highlight c linenos %}
typedef enum
{
    TOKEN_COLON,
    TOKEN_COMMA,
    TOKEN_ASTERISK,

    TOKEN_ARROW,

    TOKEN_LEFT_PAREN,
    TOKEN_RIGHT_PAREN,
    TOKEN_LEFT_BRACE,
    TOKEN_RIGHT_BRACE,
    TOKEN_LEFT_BRACKET,
    TOKEN_RIGHT_BRACKET,
    
    /* literals */
    TOKEN_IDENTIFIER,
    TOKEN_STRING,

    /* keywords */
    TOKEN_ENUM,
    TOKEN_DEFINE,
    TOKEN_INCLUDE,
    TOKEN_GENERATE,

    TOKEN_ERROR,
    TOKEN_EOF
} TokenType;
{% endhighlight %}

These may vary if you have a different requirements and a different syntax.

{% highlight c linenos %}
static int is_alpha(char c)
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c == '_');
}

static int is_digit(char c)
{
    return c >= '0' && c <= '9';
}

static Token make_token(const Scanner* scanner, TokenType type)
{
    Token token;
    token.type = type;
    token.start = scanner->start;
    token.len = scanner->current - scanner->start;
    token.line = scanner->line;

    return token;
}

static Token make_token_error(const Scanner* scanner, const char* message)
{
    Token token;
    token.type = TOKEN_ERROR;
    token.start = message;
    token.len = strlen(message);
    token.line = scanner->line;

    return token;
}

static Token make_string(Scanner* scanner)
{
    while(scanner->current[0] != '"')
    {
        if (scanner->current[0] == '\0' || scanner->current[0] == '\n')
            return make_token_error(scanner, "Unterminated string.");

        scanner->current++;
    }

    scanner->current++; /* closing quote */
    return make_token(scanner, TOKEN_STRING);
}

static TokenType check_keyword(const Scanner* scanner, const char* keyword, TokenType type)
{
    size_t len = strlen(keyword);
    if ((scanner->current - scanner->start == len) && memcmp(scanner->start, keyword, len) == 0)
        return type;

    return TOKEN_IDENTIFIER;
}

static TokenType get_identifier_type(const Scanner* scanner)
{
    switch (scanner->start[0])
    {
    case 'd': return check_keyword(scanner, "define", TOKEN_DEFINE);
    case 'e': return check_keyword(scanner, "enum", TOKEN_ENUM);
    case 'g': return check_keyword(scanner, "generate", TOKEN_GENERATE);
    case 'i': return check_keyword(scanner, "include", TOKEN_INCLUDE);
    }

    return TOKEN_IDENTIFIER;
}

static Token make_identifier(Scanner* scanner)
{
    while (is_alpha(scanner->current[0]) || is_digit(scanner->current[0])) 
        scanner->current++;

    return make_token(scanner, get_identifier_type(scanner));
}

void scanner_init(Scanner* scanner, const char* source)
{
    scanner->start = source;
    scanner->current = source;

    scanner->line = 1;
}

static int scanner_match(Scanner* scanner, char c)
{
    if (!(scanner->current[0] && scanner->current[0] == c))
        return 0;

    scanner->current++;
    return 1;
}

static void scanner_skip_whitespaces(Scanner* scanner)
{
    while(1)
    {
        switch (scanner->current[0])
        {
        case ' ':
        case '\r':
        case '\t':
            scanner->current++;
            break;

        case '\n':
            scanner->line++;
            scanner->current++;
            break;

        /* Comments */
        case '#':
            while(scanner->current[0] && scanner->current[0] != '\n')
                scanner->current++;
        
        default:
            return;
        }
    }
}

Token scanner_get_next(Scanner* scanner)
{
    scanner_skip_whitespaces(scanner);
    
    scanner->start = scanner->current;

    if (!scanner->current[0]) return make_token(scanner, TOKEN_EOF);

    char c = scanner->current[0];
    scanner->current++;

    if (is_alpha(c)) return make_identifier(scanner);

    switch (c)
    {
    case ':': return make_token(scanner, TOKEN_COLON);
    case ',': return make_token(scanner, TOKEN_COMMA);
    case '*': return make_token(scanner, TOKEN_ASTERISK);

    case '(': return make_token(scanner, TOKEN_LEFT_PAREN);
    case ')': return make_token(scanner, TOKEN_RIGHT_PAREN);
    case '{': return make_token(scanner, TOKEN_LEFT_BRACE);
    case '}': return make_token(scanner, TOKEN_RIGHT_BRACE);
    case '[': return make_token(scanner, TOKEN_LEFT_BRACKET);
    case ']': return make_token(scanner, TOKEN_RIGHT_BRACKET);

    case '-':
        if (scanner_match(scanner, '>'))
            return make_token(scanner, TOKEN_ARROW);
        else
            return make_token_error(scanner, "Expected '>' after '-'.");

    case '"': return make_string(scanner);
    
    default:
        break;
    }

    return make_token_error(scanner, "Unexpected character.");
}

int token_cmp(Token* token, const char* str)
{
    return strncmp(token->start, str, token->len);
}

void print_token(Token* token)
{
    printf("%2d: %.*s\n", token->type, token->len, token->start);
}
{% endhighlight %}