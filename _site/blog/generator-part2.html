<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/style.css" />
    
    <!-- Font Aweseome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.min.css" />

    <title>
      { oliver.jakobs } 
      writing a code generation tool (part 2): the scanner
    </title>

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Writing a code generation tool (Part 2): The Scanner</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Writing a code generation tool (Part 2): The Scanner" />
<meta name="author" content="oliver" />
<meta property="og:locale" content="C" />
<meta name="description" content="The Scanner" />
<meta property="og:description" content="The Scanner" />
<link rel="canonical" href="http://localhost:4000/blog/generator-part2" />
<meta property="og:url" content="http://localhost:4000/blog/generator-part2" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-10-05T17:57:44+02:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","datePublished":"2020-10-05T17:57:44+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/generator-part2"},"url":"http://localhost:4000/blog/generator-part2","author":{"@type":"Person","name":"oliver"},"description":"The Scanner","headline":"Writing a code generation tool (Part 2): The Scanner","dateModified":"2020-10-05T17:57:44+02:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>
    <nav class="navbar container">
  <a class="logo" href="/">oliver.jakobs</a>
  <ul class="menu">
    
      <li><a href="/blog" >blog</a></li>
    
  </ul>
</nav>
    <main class="page-content container"><a href="/blog">&laquo; Back</a>

<h1 class="post-title">Writing a code generation tool (Part 2): The Scanner</h1>
<ul class="post-meta">
  <li><i class="far fa-calendar"></i>05 Oct 2020</li>
  <li><i class="far fa-user"></i>oliver</li>
  <li><i class="fas fa-code"></i>C</li>
</ul>

<article class="post-content">
  <h2 id="the-scanner">The Scanner</h2>

<p>Before we can generate any code we need to split the script file into a list of tokens. This makes it easier to 
handle the script. To do so we need to scan the whole file and look for lexemes that correspond with the defined 
set of Tokens. For my requirements I needed the following types of token:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
    <span class="n">TOKEN_COLON</span><span class="p">,</span>
    <span class="n">TOKEN_COMMA</span><span class="p">,</span>
    <span class="n">TOKEN_ASTERISK</span><span class="p">,</span>

    <span class="n">TOKEN_ARROW</span><span class="p">,</span>

    <span class="n">TOKEN_LEFT_PAREN</span><span class="p">,</span>
    <span class="n">TOKEN_RIGHT_PAREN</span><span class="p">,</span>
    <span class="n">TOKEN_LEFT_BRACE</span><span class="p">,</span>
    <span class="n">TOKEN_RIGHT_BRACE</span><span class="p">,</span>
    <span class="n">TOKEN_LEFT_BRACKET</span><span class="p">,</span>
    <span class="n">TOKEN_RIGHT_BRACKET</span><span class="p">,</span>
    
    <span class="cm">/* literals */</span>
    <span class="n">TOKEN_IDENTIFIER</span><span class="p">,</span>
    <span class="n">TOKEN_STRING</span><span class="p">,</span>

    <span class="cm">/* keywords */</span>
    <span class="n">TOKEN_ENUM</span><span class="p">,</span>
    <span class="n">TOKEN_DEFINE</span><span class="p">,</span>
    <span class="n">TOKEN_INCLUDE</span><span class="p">,</span>
    <span class="n">TOKEN_GENERATE</span><span class="p">,</span>

    <span class="n">TOKEN_ERROR</span><span class="p">,</span>
    <span class="n">TOKEN_EOF</span>   <span class="cm">/* end of file */</span>
<span class="p">}</span> <span class="n">TokenType</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Be aware that these types are depended of your requirements and syntax choices. The types ‘TOKEN_ERROR’ and ‘TOKEN_EOF’ 
are probably useful for every project to identify the end of the file and to help find mistakes in the script file.</p>

<p>To keep track of where we are in the file and what we are currently scanning we define the following struct to help us 
with that:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">current</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">line</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Scanner</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We use ‘start’ to point to the start of the lexeme we are currently scanning and ‘current’ to point to the character we 
are currently looking at. The ‘line’ keeps track of the line in the script where we are at, to help us with debugging.</p>

<p>We initialize the scanner by letting ‘start’ and ‘current’ point to the beginning of the script file. We should 
probably use a function to do that for us. We also need to set the line of the scanner to 1.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="nf">scanner_init</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>
    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">=</span> <span class="n">source</span><span class="p">;</span>

    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">line</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The heart of the scanner lies in the scan function, which takes the scanner as argument and returns a Token. The 
function steps through the script file and searches for patterns which matches the various token types. Once the 
scanner found such a token it creates a token which contains the type, a pointer to the start of the token’s lexeme in 
the script and the length of the lexeme. The token also contains the number of the line where it was found for 
debugging purposes.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">TokenType</span> <span class="n">type</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">line</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Token</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Such tokens are stored in an array and will be used by the generator to decide what code to generate.</p>

<p>The full scan function is rather complex, so we will break it down to more managable pieces. The simplest version of 
the function would be this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="n">Token</span> <span class="nf">scanner_get_next</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_EOF</span><span class="p">);</span>

    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">create_token_error</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"Unexpected character."</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>With this function we check if we have reached the end of the file (by checking if ‘c’ is ‘\0’). If we are indeed at 
the end, we create a token with the type ‘TOKEN_EOF’ and if not we return an error token with an according error 
message.</p>

<p>The creation of these tokens (and other simple token) is pretty straightforward.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">static</span> <span class="n">Token</span> <span class="nf">create_token</span><span class="p">(</span><span class="k">const</span> <span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">,</span> <span class="n">TokenType</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Token</span> <span class="n">token</span><span class="p">;</span>
    <span class="n">token</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">token</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
    <span class="n">token</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">-</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
    <span class="n">token</span><span class="p">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">token</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Token</span> <span class="nf">create_token_error</span><span class="p">(</span><span class="k">const</span> <span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Token</span> <span class="n">token</span><span class="p">;</span>
    <span class="n">token</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">TOKEN_ERROR</span><span class="p">;</span>
    <span class="n">token</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">token</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="n">token</span><span class="p">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">line</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">token</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The next step on our way to the full scan function is the creation of single and double character tokens. To do so we 
add a switch statement to check if the current character matches a token. After we added the switch to the function we 
get something like this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="n">Token</span> <span class="nf">scanner_get_next</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_EOF</span><span class="p">);</span>

    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="cm">/* checking for single character token */</span>
    <span class="k">case</span> <span class="sc">':'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_COLON</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">','</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_COMMA</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'*'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_ASTERISK</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'('</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_LEFT_PAREN</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">')'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_RIGHT_PAREN</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'{'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_LEFT_BRACE</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'}'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_RIGHT_BRACE</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'['</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_LEFT_BRACKET</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">']'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_RIGHT_BRACKET</span><span class="p">);</span>

    <span class="cm">/* checking for double character token */</span>
    <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scanner_match</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="sc">'&gt;'</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_ARROW</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">create_token_error</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"Expected '&gt;' after '-'."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">create_token_error</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"Unexpected character."</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To scan double character token we need a small helper function, that checks if the current character matches a specific 
character and is not ‘\0’. If there is a match we advance the scanner by one character. Since the scripting language 
does not support arithmetic operators, we return an error token if a hyphen is not followed by a greater-than sign.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">scanner_match</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="whitespaces-and-comments">Whitespaces and comments</h2>

<p>Currently our scanner is creating a token (more specifically an error token) for every space, tab, and newline. But we 
do not care for these since they are not part of any token’s lexeme. So at the start of the scan function we should 
skip every leading whitespace. While we are at it we should possibly skip comments to. A comment starts with an ‘#’ and 
goes until the end of the line.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">scanner_skip_whitespaces</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="sc">' '</span><span class="p">:</span>
        <span class="k">case</span> <span class="sc">'\r'</span><span class="p">:</span>
        <span class="k">case</span> <span class="sc">'\t'</span><span class="p">:</span>
            <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'\n'</span><span class="p">:</span>
            <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">line</span><span class="o">++</span><span class="p">;</span>
            <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="cm">/* Comments */</span>
        <span class="k">case</span> <span class="sc">'#'</span><span class="p">:</span>
            <span class="k">while</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\n'</span><span class="p">)</span>
                <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
        
        <span class="nl">default:</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we now call this function before we set the start of our scanner we will get all the token while avoiding all 
whitespace and comments.</p>

<h2 id="strings">Strings</h2>

<p>With comments and whitespaces out of the way, we can continue with adding more token we can scan. The next type we want 
to scan is strings. A string starts and ends with ‘”’ everthing in between is part of the string. For simplicity’s sake 
we will not handle multiline strings. So if we find ‘\0’ or ‘\n’ before we reach the closing quote we want to return an 
error token indictating an unterminated was found. If we find a valid string we create a token which contains the 
string including both quotes.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">static</span> <span class="n">Token</span> <span class="nf">create_string</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'"'</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">create_token_error</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"Unterminated string."</span><span class="p">);</span>

        <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* closing quote */</span>
    <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_STRING</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To add this function to our scan function we just need to add another case (for ‘”’) to the switch statement.</p>

<h2 id="numbers">Numbers</h2>

<p>The only thing we are missing now is the scanning of numbers, identifiers and keywords. We will start with numbers, 
since they are easier. To look for numbers we first need to define a small helper function to check if a character is a
digit.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">is_digit</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>With the help of this function we can scan numbers. To do so we need to advance the scanner while the current character
is still a number. If the next character is a dot, we need to scan the fractional part as well, which is basically the 
same as the first part of this function. Put that all together and the result should look something like this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">static</span> <span class="n">Token</span> <span class="nf">create_number</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">is_digit</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="n">scanner</span><span class="o">++</span><span class="p">;</span>

    <span class="cm">/* Look for a fractional part. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="o">&amp;&amp;</span> <span class="n">is_digit</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="p">{</span>
        <span class="n">scanner</span><span class="o">++</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">is_digit</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="n">scanner</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_NUMBER</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To add this to our scan function we just need to check if our current character is a digit before we enter the switch.</p>

<h2 id="identifiers-and-keywords">Identifiers and keywords</h2>

<p>Now to identifiers and keywords. Since Keywords are “just” special, reserved indetifiers we can check for both in one 
function. First we scan the whole identifier, and since we allow numbers in our identifiers we need to check for both 
letters (and underscores) and digits. Like for the numbers we should define a helper function to check for letters.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">is_alpha</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'_'</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Additionally we need an another helper function to check if the identifier we scanned is a specific keyword. Basically 
its just a fancy wrapper for ‘memcmp’.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">static</span> <span class="n">TokenType</span> <span class="nf">check_keyword</span><span class="p">(</span><span class="k">const</span> <span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">TokenType</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">keyword</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span> <span class="o">-</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">type</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">TOKEN_IDENTIFIER</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>With the help of these two functions we can now create the ‘create_identifier’ function. Since we don’t want to compare 
every single identifier with every possible keyword, we will use a switch statement where we will look only at the 
first character of each identifier. If it matches the first character of a keyword we will check the rest of the 
identifier. If it doesn’t we just return an identifier token since it can’t be any keyword.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="k">static</span> <span class="n">Token</span> <span class="nf">create_identifier</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">is_alpha</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span> <span class="n">is_digit</span><span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> 
        <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>

    <span class="n">TokenType</span> <span class="n">identifier_type</span> <span class="o">=</span> <span class="n">TOKEN_IDENTIFIER</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">scanner</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="sc">'d'</span><span class="p">:</span> <span class="n">identifier_type</span> <span class="o">=</span> <span class="n">check_keyword</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"define"</span><span class="p">,</span> <span class="n">TOKEN_DEFINE</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'e'</span><span class="p">:</span> <span class="n">identifier_type</span> <span class="o">=</span> <span class="n">check_keyword</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"enum"</span><span class="p">,</span> <span class="n">TOKEN_ENUM</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'g'</span><span class="p">:</span> <span class="n">identifier_type</span> <span class="o">=</span> <span class="n">check_keyword</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"generate"</span><span class="p">,</span> <span class="n">TOKEN_GENERATE</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'i'</span><span class="p">:</span> <span class="n">identifier_type</span> <span class="o">=</span> <span class="n">check_keyword</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"include"</span><span class="p">,</span> <span class="n">TOKEN_INCLUDE</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'s'</span><span class="p">:</span> <span class="n">identifier_type</span> <span class="o">=</span> <span class="n">check_keyword</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"strings"</span><span class="p">,</span> <span class="n">TOKEN_STRINGS</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">identifier_type</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>If we now take everything we learned so far and pack it in one function the result should look something like this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="n">Token</span> <span class="nf">scanner_get_next</span><span class="p">(</span><span class="n">Scanner</span><span class="o">*</span> <span class="n">scanner</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">scanner_skip_whitespaces</span><span class="p">(</span><span class="n">scanner</span><span class="p">);</span>
    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_EOF</span><span class="p">);</span>

    <span class="n">scanner</span><span class="o">-&gt;</span><span class="n">current</span><span class="o">++</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">is_alpha</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">return</span> <span class="n">create_identifier</span><span class="p">(</span><span class="n">scanner</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_digit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">return</span> <span class="n">create_number</span><span class="p">(</span><span class="n">scanner</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="cm">/* checking for single character token */</span>
    <span class="k">case</span> <span class="sc">':'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_COLON</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">','</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_COMMA</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'*'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_ASTERISK</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'('</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_LEFT_PAREN</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">')'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_RIGHT_PAREN</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'{'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_LEFT_BRACE</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'}'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_RIGHT_BRACE</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">'['</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_LEFT_BRACKET</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">']'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_RIGHT_BRACKET</span><span class="p">);</span>

    <span class="cm">/* checking for double character token */</span>
    <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scanner_match</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="sc">'&gt;'</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">create_token</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">TOKEN_ARROW</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">create_token_error</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"Expected '&gt;' after '-'."</span><span class="p">);</span>

    <span class="k">case</span> <span class="sc">'"'</span><span class="p">:</span> <span class="k">return</span> <span class="n">create_string</span><span class="p">(</span><span class="n">scanner</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">create_token_error</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="s">"Unexpected character."</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The last part we should do is testing if nothing is crashing and the scanner identifies every token correctly. To do so 
we will scan a simple <a href="https://github.com/oliverjakobs/oliverjakobs.github.io/tree/draft/code/generator/scanner/test_script.cx">test script</a>.
To scan a file we just keep getting the next token until we get a token which type is ‘TOKEN_EOF’. For now every token 
we scan will be printed out in a nice, readable way.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"test_script.cx"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">fseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">ftell</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="n">fseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>

    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">tb_file_get_size</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span> <span class="o">||</span> <span class="n">fread</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Token</span> <span class="n">token</span> <span class="o">=</span> <span class="n">scanner_get_next</span><span class="p">(</span><span class="n">scanner</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TOKEN_EOF</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"%2d: %.*s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">token</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">token</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">token</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If something was unclear or you have some (constructive) critisim, feel free to leave a comment or write me on 
<a href="https://twitter.com/orwell_23">twitter</a>.</p>

<p>The complete code can be found <a href="https://github.com/oliverjakobs/oliverjakobs.github.io/tree/draft/code/generator/scanner">here</a>.</p>

</article>

<script src="https://utteranc.es/client.js" 
        repo="oliverjakobs/oliverjakobs.github.io"
        issue-term="url"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script>
</main>
    <footer class="page-footer container">
  <ul class="menu">
    
      <li><a href="/copyright.html"><i class="far fa-copyright"></i>2020 oliver jakobs</a></li>
    
      <li><a href="https://github.com/oliverjakobs"><i class="fab fa-github"></i>github</a></li>
    
      <li><a href="https://twitter.com/orwell_23"><i class="fab fa-twitter"></i>twitter</a></li>
    
  </ul>
</footer>
  </body>
</html>